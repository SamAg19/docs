{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Razor network is a decentralised oracle network. Anything which provides external data to a blockchain is called an \u201cOracle\u201d. Razor Network consists of validators who lock in their tokens as a \u201cStake\u201d and provide data to the network. The honest validators are rewarded and those who report incoherently are penalized. The core of Razor Network is a set of smart contracts, that can run on any Ethereum compatible blockchain. Razor relies on the underlying blockchain for providing certain properties such as censorship resistance, security from network partition attacks, etc. Detailed introduction For a detailed introduction, please check What is Razor Network? White paper The latest version of the whitepaper is always available at Whitepaper Smart contracts Our smart contracts are hosted at Contracts Please note that the project is in active development and breaking changes are introduced frequently. Client A javascript reference client is being developed. It can be found here: CLI Please see Client documentation for more details.","title":"Introduction"},{"location":"#introduction","text":"Razor network is a decentralised oracle network. Anything which provides external data to a blockchain is called an \u201cOracle\u201d. Razor Network consists of validators who lock in their tokens as a \u201cStake\u201d and provide data to the network. The honest validators are rewarded and those who report incoherently are penalized. The core of Razor Network is a set of smart contracts, that can run on any Ethereum compatible blockchain. Razor relies on the underlying blockchain for providing certain properties such as censorship resistance, security from network partition attacks, etc.","title":"Introduction"},{"location":"#detailed-introduction","text":"For a detailed introduction, please check What is Razor Network?","title":"Detailed introduction"},{"location":"#white-paper","text":"The latest version of the whitepaper is always available at Whitepaper","title":"White paper"},{"location":"#smart-contracts","text":"Our smart contracts are hosted at Contracts Please note that the project is in active development and breaking changes are introduced frequently.","title":"Smart contracts"},{"location":"#client","text":"A javascript reference client is being developed. It can be found here: CLI Please see Client documentation for more details.","title":"Client"},{"location":"FAQ/","text":"FAQs What is an oracle? Blockchains do not have access to the data from outside the blockchain. Such data is necessary for operation of various decentralized applications. This problem is solved by an entity called an oracle. What is Razor Network? Razor Network is truly decentralized oracle platform offering a high degree of decentralization and economic security. What is the consensus algorithm used by Razor Network? Razor Network is a Proof of Stake consensus algorithm which achieves consensus on oracle values by Truth-by-consensus algorithm. Does Razor Network have its own blockchain? Razor Network currently runs directly on Ethereum public networks. In the future, it will run on its own Proof of Stake blockchain with Honey Badger BFT. What kind of data is supported by Razor Network? Razor Network can retrieve any data which is publicly accessible on the internet. What is a Schell? Schell is the native ERC20 utility token used in Razor Network for staking purposes. It has the abbreviation SCH and symbol \u0282. Who can run a node? Razor Network is permissionless and decentralized. Anyone can run a node in the network provided they have enough Schells. How can I earn Schells? Schells can be earned by becoming a staker in the network. Schells are earned in the form of block rewards in the network. I have more questions For a detailed introduction, please check What is Razor Network?","title":"FAQs"},{"location":"FAQ/#faqs","text":"","title":"FAQs"},{"location":"FAQ/#what-is-an-oracle","text":"Blockchains do not have access to the data from outside the blockchain. Such data is necessary for operation of various decentralized applications. This problem is solved by an entity called an oracle.","title":"What is an oracle?"},{"location":"FAQ/#what-is-razor-network","text":"Razor Network is truly decentralized oracle platform offering a high degree of decentralization and economic security.","title":"What is Razor Network?"},{"location":"FAQ/#what-is-the-consensus-algorithm-used-by-razor-network","text":"Razor Network is a Proof of Stake consensus algorithm which achieves consensus on oracle values by Truth-by-consensus algorithm.","title":"What is the consensus algorithm used by Razor Network?"},{"location":"FAQ/#does-razor-network-have-its-own-blockchain","text":"Razor Network currently runs directly on Ethereum public networks. In the future, it will run on its own Proof of Stake blockchain with Honey Badger BFT.","title":"Does Razor Network have its own blockchain?"},{"location":"FAQ/#what-kind-of-data-is-supported-by-razor-network","text":"Razor Network can retrieve any data which is publicly accessible on the internet.","title":"What kind of data is supported by Razor Network?"},{"location":"FAQ/#what-is-a-schell","text":"Schell is the native ERC20 utility token used in Razor Network for staking purposes. It has the abbreviation SCH and symbol \u0282.","title":"What is a Schell?"},{"location":"FAQ/#who-can-run-a-node","text":"Razor Network is permissionless and decentralized. Anyone can run a node in the network provided they have enough Schells.","title":"Who can run a node?"},{"location":"FAQ/#how-can-i-earn-schells","text":"Schells can be earned by becoming a staker in the network. Schells are earned in the form of block rewards in the network.","title":"How can I earn Schells?"},{"location":"FAQ/#i-have-more-questions","text":"For a detailed introduction, please check What is Razor Network?","title":"I have more questions"},{"location":"client/","text":"Running a Node You will need to run a node in order to become a staker and answer to queries in the network. Installation Please check Quick Start for installation instructions Commands Run the commands in following way: node index.js <command> You can run following commands in CLI: -help See a list of available commands create <password> Creates a new wallet with given password. The wallets are stored in keys/ directory. WARNING: this is not a secure method of key generation, DO NOT use it for assets on mainnet. The code will be improved in the future to make key generation more secure. Fund this account with ether and schells to start participating in the network. You can use the full commands (stake) or the short form (s) as shown below. Supported commands: stake|s <amount> <address> <password> Stake some schells unstake|u <accountId> Unstake all schells withdraw|w <accountId> Withdraw all schells. Make sure schells are unstaked and unlocked vote|v <account> <password> Start monitoring contract, commit, vote, propose and dispute automatically transfer|t <to> <amount> <from> <password> transfer schells create|c <password> Create wallet with the given password demo|d sample query URLs createJob|j <url> <selector> <name> <repeat> <fee> <account> <password> Create oracle query job. Here, <address> is the address of the wallet generated using create command. Check the keys directory to see all available keys. Example node index.js create deadbeef node index.js stake 1000 0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c deadbeef node index.js vote 0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c deadbeef","title":"Running a Node"},{"location":"client/#running-a-node","text":"You will need to run a node in order to become a staker and answer to queries in the network.","title":"Running a Node"},{"location":"client/#installation","text":"Please check Quick Start for installation instructions","title":"Installation"},{"location":"client/#commands","text":"Run the commands in following way: node index.js <command> You can run following commands in CLI: -help See a list of available commands create <password> Creates a new wallet with given password. The wallets are stored in keys/ directory. WARNING: this is not a secure method of key generation, DO NOT use it for assets on mainnet. The code will be improved in the future to make key generation more secure. Fund this account with ether and schells to start participating in the network. You can use the full commands (stake) or the short form (s) as shown below. Supported commands: stake|s <amount> <address> <password> Stake some schells unstake|u <accountId> Unstake all schells withdraw|w <accountId> Withdraw all schells. Make sure schells are unstaked and unlocked vote|v <account> <password> Start monitoring contract, commit, vote, propose and dispute automatically transfer|t <to> <amount> <from> <password> transfer schells create|c <password> Create wallet with the given password demo|d sample query URLs createJob|j <url> <selector> <name> <repeat> <fee> <account> <password> Create oracle query job. Here, <address> is the address of the wallet generated using create command. Check the keys directory to see all available keys.","title":"Commands"},{"location":"client/#example","text":"node index.js create deadbeef node index.js stake 1000 0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c deadbeef node index.js vote 0x5a0b54d5dc17e0aadc383d2db43b0a0d3e029c4c deadbeef","title":"Example"},{"location":"contracts/","text":"Contracts The contracts can be found in our github repo here The addresses where the contracts are deployed can be found here The different kinds of contracts and their functions: State manager: Manage the state of the network Stake Manager: Staking and unstaking, penalties and rewards Vote Manager: Management of reported votes: commits and reveals Block Manager: Create new blocks on Razor Network Job Manager: This contract manager queue of pending queries and results of processed queries Delegator: Proxy contract provides access to the latest Job Manager contract.","title":"Contracts"},{"location":"contracts/#contracts","text":"The contracts can be found in our github repo here The addresses where the contracts are deployed can be found here The different kinds of contracts and their functions: State manager: Manage the state of the network Stake Manager: Staking and unstaking, penalties and rewards Vote Manager: Management of reported votes: commits and reveals Block Manager: Create new blocks on Razor Network Job Manager: This contract manager queue of pending queries and results of processed queries Delegator: Proxy contract provides access to the latest Job Manager contract.","title":"Contracts"},{"location":"explainer/","text":"What is Razor Network? This is an explanation of how Razor Network works to achieve its goals of providing a decentralized, trustworthy, fast and scalable way to provide external data to smart contracts. Anything which provides external data to a blockchain is called an \u201cOracle\u201d. Razor Network consists of validators who lock in their tokens as a \u201cStake\u201d and provide data to the network. The honest validators are rewarded and those who report incoherently are penalized. The core of Razor Network is a set of smart contracts, that can run on any Ethereum compatible blockchain. Razor relies on the underlying blockchain for providing certain properties such as censorship resistance, security from network partition attacks, etc. Goals of the protocol The goal of the project is to provide a decentralized way to verify and provide data to a blockchain. Since entire economies are being built on top of blockchain which rely heavily on the external data, it is extremely important that the data is provided and aggregated in a decentralized way to avoid many kinds of attacks. The various kinds of attacks that can be faced by a decentralized oracle such as Razor are: Takeover attack by controlling the majority of the validators Bribe attack Bribe signaling attack Providing invalid or compromised data source Making invalid queries to the oracle Censoring reports of honest validators. Apart from being secure from such attacks, Razor Network has the following features: An oracle which is both fast and secure Sufficient scalability to serve web 3.0 as well as web 2.0 applications Cover a large number of use cases by allowing results to be fetched both manually or automatically How does Razor Network compare to other oracles? Comparison of decentralized oracle networks As can be seen from the table above, there are two kinds of decentralized oracles: Oracles which have fast resolution times but are game theoretically insecure Oracles which have slow resolution times but are game theoretically secure There is a clear need in the market for an oracle which is both fast and secure. Razor network fills that gap. Razor is a decentralized oracle in contrast to Provable (formerly Oraclize), which is a centralized oracle. Such centralized solutions are not included in the comparison. How does the network achieve the goal of decentralization? Decentralization is an important goal of the network. This is because centralization puts a high amount of power in a small group of entities, which makes a lot of attacks feasible and, jeopardizes the trustworthiness of the protocol. We encourage decentralization in the protocol through the following ways: A fair and wide distribution of tokens The protocol is permissionless. We, or anyone else, don\u2019t have the power to decide who is allowed or otherwise, to participate in the network. Relies on decentralized, censorship-resistant underlying blockchain Queries are pseudorandomly assigned to the validators, making collusion and bribing difficult Commit reveal scheme for revealing the \u201cvotes\u201d and dispute mechanism makes it secure from bribing attacks. What kind of queries can be made with Razor? Razor can be used to make two kinds of queries: Automated mode queries Manual mode queries This allows Razor to cover a large number of use cases. For automated mode queries, the client must provide a URL, specify how the response should be processed to get the result. The assigned validators will automatically fetch the URL, parse the results and report it to the network. Since no manual intervention is necessary, the automated mode queries are answered relatively faster. Example of an automated mode query: URL: https://api.gemini.com/v1/pubticker/ethusd Selector: \u201clast\u201d The manual mode queries, on the other hand, do not require a source URL. The assigned validators must manually fetch the data and report it to the network. Such queries are suitable for applications such as prediction markets, where the stakes are high and a longer resolution period is acceptable. Also, a precise URL may not be available for such a query at the time the query is formed. Example of a manual mode query: Query: Who won the 2020 US election? Data Source (optional): US Mainstream media and common knowledge How are queries assigned to different validators? Queries are pseudorandomly assigned to different validators. The higher the relative stake of a validator, the higher the chances of that particular validator to get a chance to participate in the current epoch. So a subset of validators is selected in each round by lottery to avoid scalability issues and related attacks. The equation which determines this is: Where PRN is a pseudorandom number generator using a deterministic algorithm. S is the stake of the validator Sm is the maximum stake currently staked in the network. D is the automatically adjusting difficulty factor. If the validator is selected in the lottery, they will be pseudorandomly assigned a query. E.g. let\u2019s say we will be processing 4 queries this epoch. All validators generate a pseudorandom number between 0 and 1. If the generated number is between 0 and 0.25, the first job will be assigned to that validator. If it is between 0.25 and 0.5, second job and so on. How are pseudorandom numbers generated in a secure way? For various operations of the protocol, we need to generate pseudorandom numbers in a trustless way. The algorithm must be deterministic so that the calculation can be performed and verified on the blockchain. We currently use Ethereum block hashes to generate randomness. This is deterministic since the block hashes are publically known and verifiable. A block hash is basically a random 256-bit number. Dividing it by 2^256 gives a random number between 0 and 1. This is then used for various calculations in the protocol. How does the protocol achieve protection from different bribing and collusion attacks? The protocol has several countermeasures to prevent such attacks. Commit - reveal mechanism When validators report a data point, they report it in a secret way, during the commit state of the epoch. They create a \u201chash\u201d of the data point along with a secret and report that hash. Hence no one other than the validator themselves knows their own vote. This makes the reporting process discreet and avoids anyone\u2019s votes being influenced by other validators\u2019 votes. In the reveal state of the epoch, all validators reveal the secret along with their vote. The hash of this must match the hash reported by the validator in the commit state, otherwise, it will not be accepted by the smart contract. If anyone prematurely reveals their secret during the \u201ccommit\u201d state, anyone can report it to the smart contract and slash their entire stake. Hence validators are heavily disincentivized to share their secrets. Due to this mechanism, it becomes difficult to prove to the briber that you have voted in one way or the other. Dispute Resolution mechanism An attacker can bribe the majority of the stake in a trustless way and can compromise the results of the oracle. To prevent this, Razor Network has an in-built dispute resolution mechanism. Any result of the oracle can be disputed by paying the \u201cDispute bond\u201d, which can be paid collectively. The disputers win a reward of 50% of the dispute bond if they successfully dispute a round. If the bond is successfully paid within the dispute period, the query enters a dispute round. In the dispute round, the stakes are higher, the amount of penalty for voting incoherently is higher and the queries are answered manually by the validators. The results of the dispute round can be further disputed. The amount of participating stake, and the dispute bond amount is doubled every round. If the disputer wins the dispute, their dispute bond is refunded, else it is confiscated and rewarded to coherent validators. Due to this mechanism, even if an attacker compromises the oracle, the result will likely be disputed by an honest actor. The attacker will have to pay double the bribe to compromise the dispute round. Even if they are successful in doing that, that round will again likely be disputed and so on. This can go on till the whole network participates in the dispute round. If that round also fails to resolve the dispute, the network forks in two networks and the market decides the honest fork. How does the protocol achieve protection from invalid query attacks? A client must pay a \u201cvalidity bond\u201d for making a query on Razor. This is in addition to the transaction fee for making the query. The validity bond will be confiscated if the query is ruled out as invalid, else it is refunded back to the client after the results are finalized. Since investigating query requires manual intervention, this can only be done in dispute rounds and manual rounds. An attacker may make an invalid query to the network in the following ways: Invalid data-source The attacker may provide a data-source which is non-responsive, provides unreliable data, or lacks trustworthiness. Invalid query The query itself may be invalid. For example \u201cIs this statement correct?\u201d is an invalid query. How does the protocol achieve protection from various network attacks? Network partitioning, eclipse attacks, censorship attacks Razor is a set of smart contracts running on the underlying blockchain. It is the job of the underlying blockchain to protect itself on such attacks. We will either be using Ethereum main net which is secure from such attacks or a scalability solution that has the same properties. Frontrunning attacks The smart contracts have been carefully designed to make front running either impossible or indifferent from a normal transaction. Transaction withholding attack A validator can vote for epoch (e). The miner may withhold this transaction for (n) epochs and mine it in epoch (e + n). This may penalize the honest validator since the transactions on Razor network are time-sensitive and the result of a data feed may be different at epoch (e) and (e + n). To prevent this from happening, the epoch is included in all transactions on the network and only transactions from the current epoch are considered valid. This is an extra precaution as withholding attacks will fail in a censorship-resistant network. How are potential smart contract vulnerabilities addressed? Out of gas vulnerabilities In these types of vulnerabilities, the smart contract is stuck in a state because the state changing function requires gas that is higher than the gas limit of the network. The smart contracts have been carefully designed to avoid loops. In the case where loops are unavoidable, such transactions are allowed to be completed in batches to avoid out of gas errors. A lot of the calculations are outsourced to the validators in a trustless manner. Re-entrancy attacks Re-entrancy attacks are kept in mind while developing the smart contracts. Other bugs and vulnerabilities Smart contracts will be audited by at least two external teams to make sure the contracts are bug-free. Smart contract/network architecture A simplified network and smart contract architecture is shown below. The illustration shows the case where the client application is hosted on the same blockchain as Razor Network smart contracts. The case where the application is on a different network is not shown. Smart contracts and network architecture Functions of the various contracts: State manager: Manage the state of the network Stake Manager: Staking and unstaking, penalties and rewards Vote Manager: Management of reported votes: commits and reveals Block Manager: Create new blocks on Razor Network Job Manager: This contract manager queue of pending queries and results of processed queries Delegator: Proxy contract provides access to the latest Job Manager contract. Various utility libraries, storage contracts, and interfaces are not shown for clarity purposes. How is the required scalability achieved? Razor relies on an underlying blockchain for various features such as: Achieving low-level consensus Host EVM smart contracts Store data Protect from double-spending attacks Avoid censorship attacks Avoid network partitioning and eclipse attacks and so on Since all the operations and communication in Razor happens via transactions on the blockchain, the underlying blockchain must be able to handle the capacity requirement in addition to the desired features mentioned above. For these reasons, the initial version of the network will be released on top of Ethereum Network. In the future, a separate Ethereum Virtual Machine compatible blockchain will be deployed. This blockchain will be a Proof of Stake blockchain which uses the Honey Badger BFT consensus algorithm. This particular consensus algorithm was chosen due to the following reasons: Honey Badger BFT provides instant finality The transactions are encrypted before being included in the block. This provides censorship resistance Supports a large number of stakers and staking pools. Provides asynchronicity and smaller block times Honey Badger BFT was created by Cornell University and is being implemented by https://poa.network Other scalability solutions may be explored in the future if necessary. How can a decentralized application use Razor? What is the information flow? How a prediction market can use Razor Network Oracle: Alice creates a new betting contract: \"Who wins the 2020 US election?\" Alice has to pay a \"Validity bond\" to guarantee that this is a valid query. The validity bond will be paid back to her if the query is not ruled out as \"Invalid\" Alice bets 1 ETH that \"Trump\" will win the election. Bob bets against Alice that \"Andrew\" will win the election. Different users can bet on different outcomes similarly. All the bets will be locked in the smart contract until the bets are settled. The betting contract can only ask this question to the Razor oracle at a later date decided in advance. Let's say December 2020. And then settle the bet. This action can be triggered by anyone but only after the specified date. Since this query will be initiated in the \"manual\" mode, no data source will be provided. The validators will manually search the internet and report the winner of the election to the Razor Network. The result will be finalized in the Razor Network after the cycle is finished. After this happens, anyone can trigger the \"settle\" action in the betting smart contract. The betting smart contract will then query the Razor smart contract to see the result, and then settle the bet accordingly.","title":"What is Razor Network?"},{"location":"explainer/#what-is-razor-network","text":"This is an explanation of how Razor Network works to achieve its goals of providing a decentralized, trustworthy, fast and scalable way to provide external data to smart contracts. Anything which provides external data to a blockchain is called an \u201cOracle\u201d. Razor Network consists of validators who lock in their tokens as a \u201cStake\u201d and provide data to the network. The honest validators are rewarded and those who report incoherently are penalized. The core of Razor Network is a set of smart contracts, that can run on any Ethereum compatible blockchain. Razor relies on the underlying blockchain for providing certain properties such as censorship resistance, security from network partition attacks, etc.","title":"What is Razor Network?"},{"location":"explainer/#goals-of-the-protocol","text":"The goal of the project is to provide a decentralized way to verify and provide data to a blockchain. Since entire economies are being built on top of blockchain which rely heavily on the external data, it is extremely important that the data is provided and aggregated in a decentralized way to avoid many kinds of attacks. The various kinds of attacks that can be faced by a decentralized oracle such as Razor are: Takeover attack by controlling the majority of the validators Bribe attack Bribe signaling attack Providing invalid or compromised data source Making invalid queries to the oracle Censoring reports of honest validators.","title":"Goals of the protocol"},{"location":"explainer/#apart-from-being-secure-from-such-attacks-razor-network-has-the-following-features","text":"An oracle which is both fast and secure Sufficient scalability to serve web 3.0 as well as web 2.0 applications Cover a large number of use cases by allowing results to be fetched both manually or automatically","title":"Apart from being secure from such attacks, Razor Network has the following features:"},{"location":"explainer/#how-does-razor-network-compare-to-other-oracles","text":"Comparison of decentralized oracle networks As can be seen from the table above, there are two kinds of decentralized oracles: Oracles which have fast resolution times but are game theoretically insecure Oracles which have slow resolution times but are game theoretically secure There is a clear need in the market for an oracle which is both fast and secure. Razor network fills that gap. Razor is a decentralized oracle in contrast to Provable (formerly Oraclize), which is a centralized oracle. Such centralized solutions are not included in the comparison.","title":"How does Razor Network compare to other oracles?"},{"location":"explainer/#how-does-the-network-achieve-the-goal-of-decentralization","text":"Decentralization is an important goal of the network. This is because centralization puts a high amount of power in a small group of entities, which makes a lot of attacks feasible and, jeopardizes the trustworthiness of the protocol. We encourage decentralization in the protocol through the following ways: A fair and wide distribution of tokens The protocol is permissionless. We, or anyone else, don\u2019t have the power to decide who is allowed or otherwise, to participate in the network. Relies on decentralized, censorship-resistant underlying blockchain Queries are pseudorandomly assigned to the validators, making collusion and bribing difficult Commit reveal scheme for revealing the \u201cvotes\u201d and dispute mechanism makes it secure from bribing attacks.","title":"How does the network achieve the goal of decentralization?"},{"location":"explainer/#what-kind-of-queries-can-be-made-with-razor","text":"Razor can be used to make two kinds of queries: Automated mode queries Manual mode queries This allows Razor to cover a large number of use cases. For automated mode queries, the client must provide a URL, specify how the response should be processed to get the result. The assigned validators will automatically fetch the URL, parse the results and report it to the network. Since no manual intervention is necessary, the automated mode queries are answered relatively faster.","title":"What kind of queries can be made with Razor?"},{"location":"explainer/#example-of-an-automated-mode-query","text":"URL: https://api.gemini.com/v1/pubticker/ethusd Selector: \u201clast\u201d The manual mode queries, on the other hand, do not require a source URL. The assigned validators must manually fetch the data and report it to the network. Such queries are suitable for applications such as prediction markets, where the stakes are high and a longer resolution period is acceptable. Also, a precise URL may not be available for such a query at the time the query is formed.","title":"Example of an automated mode query:"},{"location":"explainer/#example-of-a-manual-mode-query","text":"Query: Who won the 2020 US election? Data Source (optional): US Mainstream media and common knowledge","title":"Example of a manual mode query:"},{"location":"explainer/#how-are-queries-assigned-to-different-validators","text":"Queries are pseudorandomly assigned to different validators. The higher the relative stake of a validator, the higher the chances of that particular validator to get a chance to participate in the current epoch. So a subset of validators is selected in each round by lottery to avoid scalability issues and related attacks. The equation which determines this is: Where PRN is a pseudorandom number generator using a deterministic algorithm. S is the stake of the validator Sm is the maximum stake currently staked in the network. D is the automatically adjusting difficulty factor. If the validator is selected in the lottery, they will be pseudorandomly assigned a query. E.g. let\u2019s say we will be processing 4 queries this epoch. All validators generate a pseudorandom number between 0 and 1. If the generated number is between 0 and 0.25, the first job will be assigned to that validator. If it is between 0.25 and 0.5, second job and so on.","title":"How are queries assigned to different validators?"},{"location":"explainer/#how-are-pseudorandom-numbers-generated-in-a-secure-way","text":"For various operations of the protocol, we need to generate pseudorandom numbers in a trustless way. The algorithm must be deterministic so that the calculation can be performed and verified on the blockchain. We currently use Ethereum block hashes to generate randomness. This is deterministic since the block hashes are publically known and verifiable. A block hash is basically a random 256-bit number. Dividing it by 2^256 gives a random number between 0 and 1. This is then used for various calculations in the protocol.","title":"How are pseudorandom numbers generated in a secure way?"},{"location":"explainer/#how-does-the-protocol-achieve-protection-from-different-bribing-and-collusion-attacks","text":"The protocol has several countermeasures to prevent such attacks.","title":"How does the protocol achieve protection from different bribing and collusion attacks?"},{"location":"explainer/#commit-45-reveal-mechanism","text":"When validators report a data point, they report it in a secret way, during the commit state of the epoch. They create a \u201chash\u201d of the data point along with a secret and report that hash. Hence no one other than the validator themselves knows their own vote. This makes the reporting process discreet and avoids anyone\u2019s votes being influenced by other validators\u2019 votes. In the reveal state of the epoch, all validators reveal the secret along with their vote. The hash of this must match the hash reported by the validator in the commit state, otherwise, it will not be accepted by the smart contract. If anyone prematurely reveals their secret during the \u201ccommit\u201d state, anyone can report it to the smart contract and slash their entire stake. Hence validators are heavily disincentivized to share their secrets. Due to this mechanism, it becomes difficult to prove to the briber that you have voted in one way or the other.","title":"Commit - reveal mechanism"},{"location":"explainer/#dispute-resolution-mechanism","text":"An attacker can bribe the majority of the stake in a trustless way and can compromise the results of the oracle. To prevent this, Razor Network has an in-built dispute resolution mechanism. Any result of the oracle can be disputed by paying the \u201cDispute bond\u201d, which can be paid collectively. The disputers win a reward of 50% of the dispute bond if they successfully dispute a round. If the bond is successfully paid within the dispute period, the query enters a dispute round. In the dispute round, the stakes are higher, the amount of penalty for voting incoherently is higher and the queries are answered manually by the validators. The results of the dispute round can be further disputed. The amount of participating stake, and the dispute bond amount is doubled every round. If the disputer wins the dispute, their dispute bond is refunded, else it is confiscated and rewarded to coherent validators. Due to this mechanism, even if an attacker compromises the oracle, the result will likely be disputed by an honest actor. The attacker will have to pay double the bribe to compromise the dispute round. Even if they are successful in doing that, that round will again likely be disputed and so on. This can go on till the whole network participates in the dispute round. If that round also fails to resolve the dispute, the network forks in two networks and the market decides the honest fork.","title":"Dispute Resolution mechanism"},{"location":"explainer/#how-does-the-protocol-achieve-protection-from-invalid-query-attacks","text":"A client must pay a \u201cvalidity bond\u201d for making a query on Razor. This is in addition to the transaction fee for making the query. The validity bond will be confiscated if the query is ruled out as invalid, else it is refunded back to the client after the results are finalized. Since investigating query requires manual intervention, this can only be done in dispute rounds and manual rounds. An attacker may make an invalid query to the network in the following ways:","title":"How does the protocol achieve protection from invalid query attacks?"},{"location":"explainer/#invalid-data45source","text":"The attacker may provide a data-source which is non-responsive, provides unreliable data, or lacks trustworthiness.","title":"Invalid data-source"},{"location":"explainer/#invalid-query","text":"The query itself may be invalid. For example \u201cIs this statement correct?\u201d is an invalid query.","title":"Invalid query"},{"location":"explainer/#how-does-the-protocol-achieve-protection-from-various-network-attacks","text":"","title":"How does the protocol achieve protection from various network attacks?"},{"location":"explainer/#network-partitioning-eclipse-attacks-censorship-attacks","text":"Razor is a set of smart contracts running on the underlying blockchain. It is the job of the underlying blockchain to protect itself on such attacks. We will either be using Ethereum main net which is secure from such attacks or a scalability solution that has the same properties.","title":"Network partitioning, eclipse attacks, censorship attacks"},{"location":"explainer/#frontrunning-attacks","text":"The smart contracts have been carefully designed to make front running either impossible or indifferent from a normal transaction.","title":"Frontrunning attacks"},{"location":"explainer/#transaction-withholding-attack","text":"A validator can vote for epoch (e). The miner may withhold this transaction for (n) epochs and mine it in epoch (e + n). This may penalize the honest validator since the transactions on Razor network are time-sensitive and the result of a data feed may be different at epoch (e) and (e + n). To prevent this from happening, the epoch is included in all transactions on the network and only transactions from the current epoch are considered valid. This is an extra precaution as withholding attacks will fail in a censorship-resistant network.","title":"Transaction withholding attack"},{"location":"explainer/#how-are-potential-smart-contract-vulnerabilities-addressed","text":"","title":"How are potential smart contract vulnerabilities addressed?"},{"location":"explainer/#out-of-gas-vulnerabilities","text":"In these types of vulnerabilities, the smart contract is stuck in a state because the state changing function requires gas that is higher than the gas limit of the network. The smart contracts have been carefully designed to avoid loops. In the case where loops are unavoidable, such transactions are allowed to be completed in batches to avoid out of gas errors. A lot of the calculations are outsourced to the validators in a trustless manner.","title":"Out of gas vulnerabilities"},{"location":"explainer/#re-entrancy-attacks","text":"Re-entrancy attacks are kept in mind while developing the smart contracts.","title":"Re-entrancy attacks"},{"location":"explainer/#other-bugs-and-vulnerabilities","text":"Smart contracts will be audited by at least two external teams to make sure the contracts are bug-free.","title":"Other bugs and vulnerabilities"},{"location":"explainer/#smart-contractnetwork-architecture","text":"A simplified network and smart contract architecture is shown below. The illustration shows the case where the client application is hosted on the same blockchain as Razor Network smart contracts. The case where the application is on a different network is not shown. Smart contracts and network architecture Functions of the various contracts: State manager: Manage the state of the network Stake Manager: Staking and unstaking, penalties and rewards Vote Manager: Management of reported votes: commits and reveals Block Manager: Create new blocks on Razor Network Job Manager: This contract manager queue of pending queries and results of processed queries Delegator: Proxy contract provides access to the latest Job Manager contract. Various utility libraries, storage contracts, and interfaces are not shown for clarity purposes.","title":"Smart contract/network architecture"},{"location":"explainer/#how-is-the-required-scalability-achieved","text":"Razor relies on an underlying blockchain for various features such as: Achieving low-level consensus Host EVM smart contracts Store data Protect from double-spending attacks Avoid censorship attacks Avoid network partitioning and eclipse attacks and so on Since all the operations and communication in Razor happens via transactions on the blockchain, the underlying blockchain must be able to handle the capacity requirement in addition to the desired features mentioned above. For these reasons, the initial version of the network will be released on top of Ethereum Network. In the future, a separate Ethereum Virtual Machine compatible blockchain will be deployed. This blockchain will be a Proof of Stake blockchain which uses the Honey Badger BFT consensus algorithm. This particular consensus algorithm was chosen due to the following reasons: Honey Badger BFT provides instant finality The transactions are encrypted before being included in the block. This provides censorship resistance Supports a large number of stakers and staking pools. Provides asynchronicity and smaller block times Honey Badger BFT was created by Cornell University and is being implemented by https://poa.network Other scalability solutions may be explored in the future if necessary.","title":"How is the required scalability achieved?"},{"location":"explainer/#how-can-a-decentralized-application-use-razor-what-is-the-information-flow","text":"How a prediction market can use Razor Network Oracle: Alice creates a new betting contract: \"Who wins the 2020 US election?\" Alice has to pay a \"Validity bond\" to guarantee that this is a valid query. The validity bond will be paid back to her if the query is not ruled out as \"Invalid\" Alice bets 1 ETH that \"Trump\" will win the election. Bob bets against Alice that \"Andrew\" will win the election. Different users can bet on different outcomes similarly. All the bets will be locked in the smart contract until the bets are settled. The betting contract can only ask this question to the Razor oracle at a later date decided in advance. Let's say December 2020. And then settle the bet. This action can be triggered by anyone but only after the specified date. Since this query will be initiated in the \"manual\" mode, no data source will be provided. The validators will manually search the internet and report the winner of the election to the Razor Network. The result will be finalized in the Razor Network after the cycle is finished. After this happens, anyone can trigger the \"settle\" action in the betting smart contract. The betting smart contract will then query the Razor smart contract to see the result, and then settle the bet accordingly.","title":"How can a decentralized application use Razor? What is the information flow?"},{"location":"Quick Start/Stake/","text":"Quick start - Stake Razor network is a proof of stake network. In order to participate in the network as a validator, you will need to \"Stake\" your Schells. Schells are the native tokens in the network and they are compatible with the ERC20 tokens standard. Warning: Razor network is in alpha state and is deployed on g\u00f6rli testnet. Please don't use assets with value. Get tokens You will need some g\u00f6rli ether to pay for transaction fees. You can get some here: https://goerli-faucet.slock.it/ OR https://faucet.goerli.mudit.blog/ In order to get started, you will also need some G\u00f6rli schells. Use an ethereum compatible browser (e.g. Chrome browser with Metamask plugin) Set the network to \"G\u00f6rli testnet\" in Metamask Go to https://razorscan.io/#/faucet Paste your ethereum address in the address field. Click \"Get SCH\" After a few minutes, after your transaction is confirmed, click \"Check SCH Balance\" to confirm you have received some free testnet schells. Now you are all set! Let's download the CLI client and start staking! Download and Install You will need a development environment with git, python and nodejs to get started. Please check the internet on guides about how to install these. In future we will provide a docker container to make things easier. Clone the repositoy https://github.com/razor-network/cli git clone git@github.com:razor-network/cli.git Go to the cloned directory cd cli Install packages npm i Create a directory called keys mkdir keys Rename the file config-sample.json to sample.json mv config-sample.json config.json Edit config.json to add your Ethereum node address (private or infura) Create a new wallet Create a new ethereum wallet with a password of your choice. node index.js c <password> You can check the keys directory for available wallets. ls keys Send your Schells and g\u00f6rli ether to this address. Stake Stake schells using this command node index.js stake <amount of schells to stake> <your ethereum address> <your password> Example: node index.js stake 1000 0xdeadbeef password123 Wait for the staking process to continue. It may take upto 10 minutes. Now you have staked your schells and must start validating queries to avoid inactivity penalties. To start validating, use this command node index.js vote <your ethereum address> <your password> Example: node index.js vote 0xdeadbeef password123 Your node will start automatically fetching and answering queries. You must keep our computer online to be able to validate without any interruptions.","title":"Stake"},{"location":"Quick Start/Stake/#quick-start-stake","text":"Razor network is a proof of stake network. In order to participate in the network as a validator, you will need to \"Stake\" your Schells. Schells are the native tokens in the network and they are compatible with the ERC20 tokens standard. Warning: Razor network is in alpha state and is deployed on g\u00f6rli testnet. Please don't use assets with value.","title":"Quick start - Stake"},{"location":"Quick Start/Stake/#get-tokens","text":"You will need some g\u00f6rli ether to pay for transaction fees. You can get some here: https://goerli-faucet.slock.it/ OR https://faucet.goerli.mudit.blog/ In order to get started, you will also need some G\u00f6rli schells. Use an ethereum compatible browser (e.g. Chrome browser with Metamask plugin) Set the network to \"G\u00f6rli testnet\" in Metamask Go to https://razorscan.io/#/faucet Paste your ethereum address in the address field. Click \"Get SCH\" After a few minutes, after your transaction is confirmed, click \"Check SCH Balance\" to confirm you have received some free testnet schells. Now you are all set! Let's download the CLI client and start staking!","title":"Get tokens"},{"location":"Quick Start/Stake/#download-and-install","text":"You will need a development environment with git, python and nodejs to get started. Please check the internet on guides about how to install these. In future we will provide a docker container to make things easier. Clone the repositoy https://github.com/razor-network/cli git clone git@github.com:razor-network/cli.git Go to the cloned directory cd cli Install packages npm i Create a directory called keys mkdir keys Rename the file config-sample.json to sample.json mv config-sample.json config.json Edit config.json to add your Ethereum node address (private or infura)","title":"Download and Install"},{"location":"Quick Start/Stake/#create-a-new-wallet","text":"Create a new ethereum wallet with a password of your choice. node index.js c <password> You can check the keys directory for available wallets. ls keys Send your Schells and g\u00f6rli ether to this address.","title":"Create a new wallet"},{"location":"Quick Start/Stake/#stake","text":"Stake schells using this command node index.js stake <amount of schells to stake> <your ethereum address> <your password> Example: node index.js stake 1000 0xdeadbeef password123 Wait for the staking process to continue. It may take upto 10 minutes. Now you have staked your schells and must start validating queries to avoid inactivity penalties. To start validating, use this command node index.js vote <your ethereum address> <your password> Example: node index.js vote 0xdeadbeef password123 Your node will start automatically fetching and answering queries. You must keep our computer online to be able to validate without any interruptions.","title":"Stake"},{"location":"Quick Start/usage/","text":"Use the Oracle Razor network is currently live on G\u00f6rli Ethereum testnet. So you can deploy your applications on G\u00f6rli and use Razor to fetch data for your applications. Create a new query You can currently make two kinds of queries on Razor. A simple one-time Query A datafeed which gets updated every epoch Create a datafeed query using RazorScan RazorScan provides an easy to use GUI to create datafeed queries on Razor Easily. Make sure you are using a ethereum compatible browser (e.g. Chrome + Metamask) and set the network to G\u00f6rli testnet. You will need some G\u00f6rli ether to pay for transaction fees. Go to https://razorscan.io/#/query and enter a URL which reponds with a JSON formatted data Enter a JSON Selector Enter the name of the datafeed Click \"Test query\" You can create the query by clicking \"Create query\" button. Currently, it may take upto 20 minutes for the query to be answered. You can go to https://razorscan.io/#/custom to see results of your query. Creating datafeed programmatically You can create the datafeed programmatically as well by interacting with the Job Manager contract. The source code for job manager can be found here: JobManager.sol The Address of the job manager contract can be found here Note: Currently creating queries on Razor is free of cost. Get the results from the Oracle You can access the proxy delegator contract to get the results of the datafeeds. You will need to know the \"Job ID\" of your query. You can go to https://razorscan.io/#/custom and select your query to know the Job ID of your query. You can call the \"getResult\" method of Delegator to get latest result of your query. The source of the contract is here : Delegator.sol You can alternatively call \"getJob\" method of the same contract to get more information about the query such as name, url, selector, etc. The address of the delegator contract can be found here","title":"Use the Oracle"},{"location":"Quick Start/usage/#use-the-oracle","text":"Razor network is currently live on G\u00f6rli Ethereum testnet. So you can deploy your applications on G\u00f6rli and use Razor to fetch data for your applications.","title":"Use the Oracle"},{"location":"Quick Start/usage/#create-a-new-query","text":"You can currently make two kinds of queries on Razor. A simple one-time Query A datafeed which gets updated every epoch","title":"Create a new query"},{"location":"Quick Start/usage/#create-a-datafeed-query-using-razorscan","text":"RazorScan provides an easy to use GUI to create datafeed queries on Razor Easily. Make sure you are using a ethereum compatible browser (e.g. Chrome + Metamask) and set the network to G\u00f6rli testnet. You will need some G\u00f6rli ether to pay for transaction fees. Go to https://razorscan.io/#/query and enter a URL which reponds with a JSON formatted data Enter a JSON Selector Enter the name of the datafeed Click \"Test query\" You can create the query by clicking \"Create query\" button. Currently, it may take upto 20 minutes for the query to be answered. You can go to https://razorscan.io/#/custom to see results of your query.","title":"Create a datafeed query using RazorScan"},{"location":"Quick Start/usage/#creating-datafeed-programmatically","text":"You can create the datafeed programmatically as well by interacting with the Job Manager contract. The source code for job manager can be found here: JobManager.sol The Address of the job manager contract can be found here Note: Currently creating queries on Razor is free of cost.","title":"Creating datafeed programmatically"},{"location":"Quick Start/usage/#get-the-results-from-the-oracle","text":"You can access the proxy delegator contract to get the results of the datafeeds. You will need to know the \"Job ID\" of your query. You can go to https://razorscan.io/#/custom and select your query to know the Job ID of your query. You can call the \"getResult\" method of Delegator to get latest result of your query. The source of the contract is here : Delegator.sol You can alternatively call \"getJob\" method of the same contract to get more information about the query such as name, url, selector, etc. The address of the delegator contract can be found here","title":"Get the results from the Oracle"},{"location":"Tutorial/G\u00f6rli/","text":"Tutorial - G\u00f6rli In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto Network These instructions are for deploying the dApp on g\u00f6rli testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic Setting up the Smart Contracts We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0x310DF80268CfB188B50291F2b7a1A26b97614F4D); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Please note that we frequently redeploy the testnet to speed up the development process. Please make sure to replace the Delegator address with the latest delegator address from ADDRESSES.md A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]); Set up the migration Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) } Set up the truffle configuration Razor network testnet is currently deployed on G\u00f6rli ethereum test network. So please make sure you are deploying the contract on g\u00f6rli testnet. Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Fund this ethereum wallet with g\u00f6rli ether obtained from a faucet such as https://goerli-faucet.slock.it/ You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js Deploy the Contracts Type the following command to deploy the contracts on g\u00f6rli testnet. truffle migrate --network goerli Setting up the frontend using Vue We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. Create a common.js file as shown here . Make sure to replace the delegator address as seen in ADDRESSES.md . The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev Instructions for using the dApp Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to g\u00f6rli. You will need some g\u00f6rli ether to pay transaction fees. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Tutorial - G\u00f6rli"},{"location":"Tutorial/G\u00f6rli/#tutorial-gorli","text":"In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto","title":"Tutorial - G\u00f6rli"},{"location":"Tutorial/G\u00f6rli/#network","text":"These instructions are for deploying the dApp on g\u00f6rli testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic","title":"Network"},{"location":"Tutorial/G\u00f6rli/#setting-up-the-smart-contracts","text":"We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0x310DF80268CfB188B50291F2b7a1A26b97614F4D); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Please note that we frequently redeploy the testnet to speed up the development process. Please make sure to replace the Delegator address with the latest delegator address from ADDRESSES.md A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]);","title":"Setting up the Smart Contracts"},{"location":"Tutorial/G\u00f6rli/#set-up-the-migration","text":"Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) }","title":"Set up the migration"},{"location":"Tutorial/G\u00f6rli/#set-up-the-truffle-configuration","text":"Razor network testnet is currently deployed on G\u00f6rli ethereum test network. So please make sure you are deploying the contract on g\u00f6rli testnet. Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Fund this ethereum wallet with g\u00f6rli ether obtained from a faucet such as https://goerli-faucet.slock.it/ You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js","title":"Set up the truffle configuration"},{"location":"Tutorial/G\u00f6rli/#deploy-the-contracts","text":"Type the following command to deploy the contracts on g\u00f6rli testnet. truffle migrate --network goerli","title":"Deploy the Contracts"},{"location":"Tutorial/G\u00f6rli/#setting-up-the-frontend-using-vue","text":"We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. Create a common.js file as shown here . Make sure to replace the delegator address as seen in ADDRESSES.md . The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev","title":"Setting up the frontend using Vue"},{"location":"Tutorial/G\u00f6rli/#instructions-for-using-the-dapp","text":"Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to g\u00f6rli. You will need some g\u00f6rli ether to pay transaction fees. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Instructions for using the dApp"},{"location":"Tutorial/Matic/","text":"Tutorial - Matic In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto Network These instructions are for deploying the dApp on Matic testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic Setting up the Smart Contracts We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle npm i -g truffle-hdwallet-provider Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Make sure to set the Razor address to 0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4 A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]); Set up the migration Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) } Set up the truffle configuration Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Currently the Matic testnet does not require ETH since the transactions are free of cost. You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js Deploy the Contracts Type the following command to deploy the contracts on Matic testnet. truffle migrate --network matic Setting up the frontend using Vue We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. You will need web3.js in order to interact with the Matic network. install it typing npm i --save web3 Create a common.js file as shown here . Make sure to replace the variable razorAddress with 0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4 and networkId with 8995 The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev Instructions for using the dApp Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to 'https://testnet2.matic.network'. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Tutorial - Matic"},{"location":"Tutorial/Matic/#tutorial-matic","text":"In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto","title":"Tutorial - Matic"},{"location":"Tutorial/Matic/#network","text":"These instructions are for deploying the dApp on Matic testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic","title":"Network"},{"location":"Tutorial/Matic/#setting-up-the-smart-contracts","text":"We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle npm i -g truffle-hdwallet-provider Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Make sure to set the Razor address to 0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4 A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]);","title":"Setting up the Smart Contracts"},{"location":"Tutorial/Matic/#set-up-the-migration","text":"Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) }","title":"Set up the migration"},{"location":"Tutorial/Matic/#set-up-the-truffle-configuration","text":"Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Currently the Matic testnet does not require ETH since the transactions are free of cost. You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js","title":"Set up the truffle configuration"},{"location":"Tutorial/Matic/#deploy-the-contracts","text":"Type the following command to deploy the contracts on Matic testnet. truffle migrate --network matic","title":"Deploy the Contracts"},{"location":"Tutorial/Matic/#setting-up-the-frontend-using-vue","text":"We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. You will need web3.js in order to interact with the Matic network. install it typing npm i --save web3 Create a common.js file as shown here . Make sure to replace the variable razorAddress with 0x49b16f1e15d611DcF87b9A3E51F86C41b2aa56E4 and networkId with 8995 The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev","title":"Setting up the frontend using Vue"},{"location":"Tutorial/Matic/#instructions-for-using-the-dapp","text":"Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to 'https://testnet2.matic.network'. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Instructions for using the dApp"},{"location":"Tutorial/SKALE/","text":"Tutorial - SKALE In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto Network These instructions are for deploying the dApp on SKALE testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic Setting up the Smart Contracts We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle npm i -g truffle-hdwallet-provider Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Make sure to set the Razor address to 0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09 A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]); Set up the migration Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) } Set up the truffle configuration Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Please fund this account with SKALE testnet ether. You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js Deploy the Contracts Type the following command to deploy the contracts on SKALE testnet. truffle migrate --network skale Setting up the frontend using Vue We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. You will need web3.js in order to interact with the SKALE network. install it typing npm i --save web3 Create a common.js file as shown here . Make sure to replace the variable razorAddress with 0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09 and networkId with 1 The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev Instructions for using the dApp Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to your SKALE endpoint. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Tutorial - SKALE"},{"location":"Tutorial/SKALE/#tutorial-skale","text":"In this tutorial we will explore how to use Razor Oracle network in your applications. We will create an application called \"King of Crypto\" using Razor network. The code for this sample app is available at https://github.com/razor-network/king-of-crypto","title":"Tutorial - SKALE"},{"location":"Tutorial/SKALE/#network","text":"These instructions are for deploying the dApp on SKALE testnet. Please click below if you want to deploy on a different network. G\u00f6rli Matic","title":"Network"},{"location":"Tutorial/SKALE/#setting-up-the-smart-contracts","text":"We will be using truffle to set up, compile and deploy the smart contracts. Truffle can be installed by npm i -g truffle npm i -g truffle-hdwallet-provider Create a new directory and type: truffle init This will setup a new truffle project. Go to the contracts subdirectory and create a new file called King.sol The smart contract has the following functionality: Get prices of different cryptocurrencies from Razor Oracle Network. Find the biggest gainer since last calculation. This is the new King of Crypto. If all cryptocurrencies lost value, find the crypto with least loss. This is the new King of Crypto. Paste the following code in that file. pragma solidity 0.5.10; interface Razor { function getResult(uint256 id) external view returns (uint256); function getJob(uint256 id) external view returns(string memory url, string memory selector, string memory name, bool repeat, uint256 result); } contract King { Razor public razor; uint256[] public jobs; uint256 public numJobs = 0; uint256 public king = 0; uint256[] public lastResults; constructor() public { razor = Razor(0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09); } function addFeed(uint256 jobId) public { jobs.push(jobId); numJobs = numJobs + 1; lastResults.push(0); } function findKing() public { uint256 highestGain = 0; uint256 highestGainer = 0; uint256 leastLoss = 0; uint256 leastLoser = 0; for(uint256 i = 0; i < jobs.length; i++) { uint256 price = razor.getResult(jobs[i]); if(price > lastResults[i]) { if(price - lastResults[i] > highestGain) { highestGain = price - lastResults[i]; highestGainer = jobs[i]; } } else if(price < lastResults[i]) { if(lastResults[i] - price < leastLoss) { leastLoss = lastResults[i] - price; leastLoser = jobs[i]; } } lastResults[i] = price; } if (highestGain > 0) { king = highestGainer; } else if (leastLoss > 0) { king = leastLoser; } } } Make sure to set the Razor address to 0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09 A datafeed can be added to the contract using the addFeed() function. This function requires a \"Job ID\", also known as the datafeed ID. You can know the available datafeeds and their ID by exploring https://razorscan.io/#/custom The instructions to create a new datafeed can be found Here The following line fetches result from Razor Oracle Network for the relevent datafeed Id. uint256 price = delegator.getResult(jobs[i]);","title":"Setting up the Smart Contracts"},{"location":"Tutorial/SKALE/#set-up-the-migration","text":"Create a new file called 2_deploy.js in the migrations director and paste the following code. This will tell truffle how to deploy the contract on the network. var King = artifacts.require('./King.sol') module.exports = async function (deployer) { deployer.then(async () => { await deployer.deploy(King) }) }","title":"Set up the migration"},{"location":"Tutorial/SKALE/#set-up-the-truffle-configuration","text":"Use an ethereum wallet such as MyEtherWallet or MyCrypto to create a new wallet with 12-word mnemonic phrase. Create a new file called .secret in the root of the project and paste the above mnemonic phrase. Please fund this account with SKALE testnet ether. You can set up truffle configuration as it suits you. You can see this file for reference. truffle-config.js","title":"Set up the truffle configuration"},{"location":"Tutorial/SKALE/#deploy-the-contracts","text":"Type the following command to deploy the contracts on SKALE testnet. truffle migrate --network skale","title":"Deploy the Contracts"},{"location":"Tutorial/SKALE/#setting-up-the-frontend-using-vue","text":"We will be using Vue to create a UI for the application. React or any other javascript framework can also be used alternatively. Vue cli can be installed by npm install -g @vue/cli In the root of the project, type the following command. Choose default options. vue create king This will create a new directory king with a blank vue project. You will need web3.js in order to interact with the SKALE network. install it typing npm i --save web3 Create a common.js file as shown here . Make sure to replace the variable razorAddress with 0xFF67C85D2e179fEFb3428Ae6909a9a0C60cF5d09 and networkId with 1 The getJob function in common.js shows how to get details of a datafeed in javascript directly from Razor Network Oracle. Modify the components/HelloWorld.vue file as shown here You can run the dApp by using the following command npm run dev","title":"Setting up the frontend using Vue"},{"location":"Tutorial/SKALE/#instructions-for-using-the-dapp","text":"Make sure you are using an ethereum compatible browser (Chrome + Metamask) and set the network to your SKALE endpoint. Add datafeeds. e.g. 1,2,5. Wait for a few minutes for tx to confirm. Click \"Calculate the current king\" Wait for a few minutes for tx to confirm. Refresh the page to see the new king of crypto.","title":"Instructions for using the dApp"}]}